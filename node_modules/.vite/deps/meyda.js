import {
  __commonJS
} from "./chunk-PLDDJCW6.js";

// node_modules/meyda/dist/web/meyda.min.js
var require_meyda_min = __commonJS({
  "node_modules/meyda/dist/web/meyda.min.js"(exports, module) {
    !(function(r, t) {
      "object" == typeof exports && "undefined" != typeof module ? module.exports = t() : "function" == typeof define && define.amd ? define(t) : (r = "undefined" != typeof globalThis ? globalThis : r || self).Meyda = t();
    })(exports, (function() {
      "use strict";
      function r(r2, t2, e2) {
        if (e2 || 2 === arguments.length) for (var a2, n2 = 0, o2 = t2.length; n2 < o2; n2++) !a2 && n2 in t2 || (a2 || (a2 = Array.prototype.slice.call(t2, 0, n2)), a2[n2] = t2[n2]);
        return r2.concat(a2 || Array.prototype.slice.call(t2));
      }
      var t = Object.freeze({ __proto__: null, blackman: function(r2) {
        for (var t2 = new Float32Array(r2), e2 = 2 * Math.PI / (r2 - 1), a2 = 2 * e2, n2 = 0; n2 < r2 / 2; n2++) t2[n2] = 0.42 - 0.5 * Math.cos(n2 * e2) + 0.08 * Math.cos(n2 * a2);
        for (n2 = Math.ceil(r2 / 2); n2 > 0; n2--) t2[r2 - n2] = t2[n2 - 1];
        return t2;
      }, hamming: function(r2) {
        for (var t2 = new Float32Array(r2), e2 = 0; e2 < r2; e2++) t2[e2] = 0.54 - 0.46 * Math.cos(2 * Math.PI * (e2 / r2 - 1));
        return t2;
      }, hanning: function(r2) {
        for (var t2 = new Float32Array(r2), e2 = 0; e2 < r2; e2++) t2[e2] = 0.5 - 0.5 * Math.cos(2 * Math.PI * e2 / (r2 - 1));
        return t2;
      }, sine: function(r2) {
        for (var t2 = Math.PI / (r2 - 1), e2 = new Float32Array(r2), a2 = 0; a2 < r2; a2++) e2[a2] = Math.sin(t2 * a2);
        return e2;
      } }), e = {};
      function a(r2) {
        for (; r2 % 2 == 0 && r2 > 1; ) r2 /= 2;
        return 1 === r2;
      }
      function n(r2, a2) {
        if ("rect" !== a2) {
          if ("" !== a2 && a2 || (a2 = "hanning"), e[a2] || (e[a2] = {}), !e[a2][r2.length]) try {
            e[a2][r2.length] = t[a2](r2.length);
          } catch (r3) {
            throw new Error("Invalid windowing function");
          }
          r2 = (function(r3, t2) {
            for (var e2 = [], a3 = 0; a3 < Math.min(r3.length, t2.length); a3++) e2[a3] = r3[a3] * t2[a3];
            return e2;
          })(r2, e[a2][r2.length]);
        }
        return r2;
      }
      function o(r2, t2, e2) {
        for (var a2 = new Float32Array(r2), n2 = 0; n2 < a2.length; n2++) a2[n2] = n2 * t2 / e2, a2[n2] = 13 * Math.atan(a2[n2] / 1315.8) + 3.5 * Math.atan(Math.pow(a2[n2] / 7518, 2));
        return a2;
      }
      function i(r2) {
        return Float32Array.from(r2);
      }
      function u(r2) {
        return 1125 * Math.log(1 + r2 / 700);
      }
      function f(r2, t2, e2) {
        for (var a2, n2 = new Float32Array(r2 + 2), o2 = new Float32Array(r2 + 2), i2 = t2 / 2, f2 = u(0), c2 = (u(i2) - f2) / (r2 + 1), l2 = new Array(r2 + 2), s2 = 0; s2 < n2.length; s2++) n2[s2] = s2 * c2, o2[s2] = (a2 = n2[s2], 700 * (Math.exp(a2 / 1125) - 1)), l2[s2] = Math.floor((e2 + 1) * o2[s2] / t2);
        for (var m2 = new Array(r2), p2 = 0; p2 < m2.length; p2++) {
          m2[p2] = new Array(e2 / 2 + 1).fill(0);
          for (s2 = l2[p2]; s2 < l2[p2 + 1]; s2++) m2[p2][s2] = (s2 - l2[p2]) / (l2[p2 + 1] - l2[p2]);
          for (s2 = l2[p2 + 1]; s2 < l2[p2 + 2]; s2++) m2[p2][s2] = (l2[p2 + 2] - s2) / (l2[p2 + 2] - l2[p2 + 1]);
        }
        return m2;
      }
      function c(t2, e2, a2, n2, o2, i2, u2) {
        void 0 === n2 && (n2 = 5), void 0 === o2 && (o2 = 2), void 0 === i2 && (i2 = true), void 0 === u2 && (u2 = 440);
        var f2 = Math.floor(a2 / 2) + 1, c2 = new Array(a2).fill(0).map((function(r2, n3) {
          return t2 * (function(r3, t3) {
            return Math.log2(16 * r3 / t3);
          })(e2 * n3 / a2, u2);
        }));
        c2[0] = c2[1] - 1.5 * t2;
        var l2, s2, m2, p2 = c2.slice(1).map((function(r2, t3) {
          return Math.max(r2 - c2[t3]);
        }), 1).concat([1]), h2 = Math.round(t2 / 2), g2 = new Array(t2).fill(0).map((function(r2, e3) {
          return c2.map((function(r3) {
            return (10 * t2 + h2 + r3 - e3) % t2 - h2;
          }));
        })), w2 = g2.map((function(r2, t3) {
          return r2.map((function(r3, e3) {
            return Math.exp(-0.5 * Math.pow(2 * g2[t3][e3] / p2[e3], 2));
          }));
        }));
        if (s2 = (l2 = w2)[0].map((function() {
          return 0;
        })), m2 = l2.reduce((function(r2, t3) {
          return t3.forEach((function(t4, e3) {
            r2[e3] += Math.pow(t4, 2);
          })), r2;
        }), s2).map(Math.sqrt), w2 = l2.map((function(r2, t3) {
          return r2.map((function(r3, t4) {
            return r3 / (m2[t4] || 1);
          }));
        })), o2) {
          var v2 = c2.map((function(r2) {
            return Math.exp(-0.5 * Math.pow((r2 / t2 - n2) / o2, 2));
          }));
          w2 = w2.map((function(r2) {
            return r2.map((function(r3, t3) {
              return r3 * v2[t3];
            }));
          }));
        }
        return i2 && (w2 = r(r([], w2.slice(3), true), w2.slice(0, 3), true)), w2.map((function(r2) {
          return r2.slice(0, f2);
        }));
      }
      function l(r2, t2) {
        for (var e2 = 0, a2 = 0, n2 = 0; n2 < t2.length; n2++) e2 += Math.pow(n2, r2) * Math.abs(t2[n2]), a2 += t2[n2];
        return e2 / a2;
      }
      function s(r2) {
        var t2 = r2.ampSpectrum, e2 = r2.barkScale, a2 = r2.numberOfBarkBands, n2 = void 0 === a2 ? 24 : a2;
        if ("object" != typeof t2 || "object" != typeof e2) throw new TypeError();
        var o2 = n2, i2 = new Float32Array(o2), u2 = 0, f2 = t2, c2 = new Int32Array(o2 + 1);
        c2[0] = 0;
        for (var l2 = e2[f2.length - 1] / o2, s2 = 1, m2 = 0; m2 < f2.length; m2++) for (; e2[m2] > l2; ) c2[s2++] = m2, l2 = s2 * e2[f2.length - 1] / o2;
        c2[o2] = f2.length - 1;
        for (m2 = 0; m2 < o2; m2++) {
          for (var p2 = 0, h2 = c2[m2]; h2 < c2[m2 + 1]; h2++) p2 += f2[h2];
          i2[m2] = Math.pow(p2, 0.23);
        }
        for (m2 = 0; m2 < i2.length; m2++) u2 += i2[m2];
        return { specific: i2, total: u2 };
      }
      function m(r2) {
        var t2 = r2.ampSpectrum;
        if ("object" != typeof t2) throw new TypeError();
        for (var e2 = new Float32Array(t2.length), a2 = 0; a2 < e2.length; a2++) e2[a2] = Math.pow(t2[a2], 2);
        return e2;
      }
      function p(r2) {
        var t2 = r2.ampSpectrum, e2 = r2.melFilterBank, a2 = r2.bufferSize;
        if ("object" != typeof t2) throw new TypeError("Valid ampSpectrum is required to generate melBands");
        if ("object" != typeof e2) throw new TypeError("Valid melFilterBank is required to generate melBands");
        for (var n2 = m({ ampSpectrum: t2 }), o2 = e2.length, i2 = Array(o2), u2 = new Float32Array(o2), f2 = 0; f2 < u2.length; f2++) {
          i2[f2] = new Float32Array(a2 / 2), u2[f2] = 0;
          for (var c2 = 0; c2 < a2 / 2; c2++) i2[f2][c2] = e2[f2][c2] * n2[c2], u2[f2] += i2[f2][c2];
          u2[f2] = Math.log(u2[f2] + 1);
        }
        return Array.prototype.slice.call(u2);
      }
      function h(r2) {
        return r2 && r2.__esModule && Object.prototype.hasOwnProperty.call(r2, "default") ? r2.default : r2;
      }
      var g = null;
      var w = h((function(r2, t2) {
        var e2 = r2.length;
        return t2 = t2 || 2, g && g[e2] || (function(r3) {
          (g = g || {})[r3] = new Array(r3 * r3);
          for (var t3 = Math.PI / r3, e3 = 0; e3 < r3; e3++) for (var a2 = 0; a2 < r3; a2++) g[r3][a2 + e3 * r3] = Math.cos(t3 * (a2 + 0.5) * e3);
        })(e2), r2.map((function() {
          return 0;
        })).map((function(a2, n2) {
          return t2 * r2.reduce((function(r3, t3, a3, o2) {
            return r3 + t3 * g[e2][a3 + n2 * e2];
          }), 0);
        }));
      }));
      var v = Object.freeze({ __proto__: null, amplitudeSpectrum: function(r2) {
        return r2.ampSpectrum;
      }, buffer: function(r2) {
        return r2.signal;
      }, chroma: function(r2) {
        var t2 = r2.ampSpectrum, e2 = r2.chromaFilterBank;
        if ("object" != typeof t2) throw new TypeError("Valid ampSpectrum is required to generate chroma");
        if ("object" != typeof e2) throw new TypeError("Valid chromaFilterBank is required to generate chroma");
        var a2 = e2.map((function(r3, e3) {
          return t2.reduce((function(t3, e4, a3) {
            return t3 + e4 * r3[a3];
          }), 0);
        })), n2 = Math.max.apply(Math, a2);
        return n2 ? a2.map((function(r3) {
          return r3 / n2;
        })) : a2;
      }, complexSpectrum: function(r2) {
        return r2.complexSpectrum;
      }, energy: function(r2) {
        var t2 = r2.signal;
        if ("object" != typeof t2) throw new TypeError();
        for (var e2 = 0, a2 = 0; a2 < t2.length; a2++) e2 += Math.pow(Math.abs(t2[a2]), 2);
        return e2;
      }, loudness: s, melBands: p, mfcc: function(r2) {
        var t2 = r2.ampSpectrum, e2 = r2.melFilterBank, a2 = r2.numberOfMFCCCoefficients, n2 = r2.bufferSize, o2 = Math.min(40, Math.max(1, a2 || 13));
        if (e2.length < o2) throw new Error("Insufficient filter bank for requested number of coefficients");
        var i2 = p({ ampSpectrum: t2, melFilterBank: e2, bufferSize: n2 });
        return w(i2).slice(0, o2);
      }, perceptualSharpness: function(r2) {
        for (var t2 = s({ ampSpectrum: r2.ampSpectrum, barkScale: r2.barkScale }), e2 = t2.specific, a2 = 0, n2 = 0; n2 < e2.length; n2++) a2 += n2 < 15 ? (n2 + 1) * e2[n2 + 1] : 0.066 * Math.exp(0.171 * (n2 + 1));
        return a2 *= 0.11 / t2.total;
      }, perceptualSpread: function(r2) {
        for (var t2 = s({ ampSpectrum: r2.ampSpectrum, barkScale: r2.barkScale }), e2 = 0, a2 = 0; a2 < t2.specific.length; a2++) t2.specific[a2] > e2 && (e2 = t2.specific[a2]);
        return Math.pow((t2.total - e2) / t2.total, 2);
      }, powerSpectrum: m, rms: function(r2) {
        var t2 = r2.signal;
        if ("object" != typeof t2) throw new TypeError();
        for (var e2 = 0, a2 = 0; a2 < t2.length; a2++) e2 += Math.pow(t2[a2], 2);
        return e2 /= t2.length, e2 = Math.sqrt(e2);
      }, spectralCentroid: function(r2) {
        var t2 = r2.ampSpectrum;
        if ("object" != typeof t2) throw new TypeError();
        return l(1, t2);
      }, spectralCrest: function(r2) {
        var t2 = r2.ampSpectrum;
        if ("object" != typeof t2) throw new TypeError();
        var e2 = 0, a2 = -1 / 0;
        return t2.forEach((function(r3) {
          e2 += Math.pow(r3, 2), a2 = r3 > a2 ? r3 : a2;
        })), e2 /= t2.length, e2 = Math.sqrt(e2), a2 / e2;
      }, spectralFlatness: function(r2) {
        var t2 = r2.ampSpectrum;
        if ("object" != typeof t2) throw new TypeError();
        for (var e2 = 0, a2 = 0, n2 = 0; n2 < t2.length; n2++) e2 += Math.log(t2[n2]), a2 += t2[n2];
        return Math.exp(e2 / t2.length) * t2.length / a2;
      }, spectralFlux: function(r2) {
        var t2 = r2.signal, e2 = r2.previousSignal, a2 = r2.bufferSize;
        if ("object" != typeof t2 || "object" != typeof e2) throw new TypeError();
        for (var n2 = 0, o2 = -a2 / 2; o2 < t2.length / 2 - 1; o2++) x = Math.abs(t2[o2]) - Math.abs(e2[o2]), n2 += (x + Math.abs(x)) / 2;
        return n2;
      }, spectralKurtosis: function(r2) {
        var t2 = r2.ampSpectrum;
        if ("object" != typeof t2) throw new TypeError();
        var e2 = t2, a2 = l(1, e2), n2 = l(2, e2), o2 = l(3, e2), i2 = l(4, e2);
        return (-3 * Math.pow(a2, 4) + 6 * a2 * n2 - 4 * a2 * o2 + i2) / Math.pow(Math.sqrt(n2 - Math.pow(a2, 2)), 4);
      }, spectralRolloff: function(r2) {
        var t2 = r2.ampSpectrum, e2 = r2.sampleRate;
        if ("object" != typeof t2) throw new TypeError();
        for (var a2 = t2, n2 = e2 / (2 * (a2.length - 1)), o2 = 0, i2 = 0; i2 < a2.length; i2++) o2 += a2[i2];
        for (var u2 = 0.99 * o2, f2 = a2.length - 1; o2 > u2 && f2 >= 0; ) o2 -= a2[f2], --f2;
        return (f2 + 1) * n2;
      }, spectralSkewness: function(r2) {
        var t2 = r2.ampSpectrum;
        if ("object" != typeof t2) throw new TypeError();
        var e2 = l(1, t2), a2 = l(2, t2), n2 = l(3, t2);
        return (2 * Math.pow(e2, 3) - 3 * e2 * a2 + n2) / Math.pow(Math.sqrt(a2 - Math.pow(e2, 2)), 3);
      }, spectralSlope: function(r2) {
        var t2 = r2.ampSpectrum, e2 = r2.sampleRate, a2 = r2.bufferSize;
        if ("object" != typeof t2) throw new TypeError();
        for (var n2 = 0, o2 = 0, i2 = new Float32Array(t2.length), u2 = 0, f2 = 0, c2 = 0; c2 < t2.length; c2++) {
          n2 += t2[c2];
          var l2 = c2 * e2 / a2;
          i2[c2] = l2, u2 += l2 * l2, o2 += l2, f2 += l2 * t2[c2];
        }
        return (t2.length * f2 - o2 * n2) / (n2 * (u2 - Math.pow(o2, 2)));
      }, spectralSpread: function(r2) {
        var t2 = r2.ampSpectrum;
        if ("object" != typeof t2) throw new TypeError();
        return Math.sqrt(l(2, t2) - Math.pow(l(1, t2), 2));
      }, zcr: function(r2) {
        var t2 = r2.signal;
        if ("object" != typeof t2) throw new TypeError();
        for (var e2 = 0, a2 = 1; a2 < t2.length; a2++) (t2[a2 - 1] >= 0 && t2[a2] < 0 || t2[a2 - 1] < 0 && t2[a2] >= 0) && e2++;
        return e2;
      } });
      function d(r2) {
        if (Array.isArray(r2)) {
          for (var t2 = 0, e2 = Array(r2.length); t2 < r2.length; t2++) e2[t2] = r2[t2];
          return e2;
        }
        return Array.from(r2);
      }
      var y = {}, S = {}, _ = { bitReverseArray: function(r2) {
        if (void 0 === y[r2]) {
          for (var t2 = (r2 - 1).toString(2).length, e2 = "0".repeat(t2), a2 = {}, n2 = 0; n2 < r2; n2++) {
            var o2 = n2.toString(2);
            o2 = e2.substr(o2.length) + o2, o2 = [].concat(d(o2)).reverse().join(""), a2[n2] = parseInt(o2, 2);
          }
          y[r2] = a2;
        }
        return y[r2];
      }, multiply: function(r2, t2) {
        return { real: r2.real * t2.real - r2.imag * t2.imag, imag: r2.real * t2.imag + r2.imag * t2.real };
      }, add: function(r2, t2) {
        return { real: r2.real + t2.real, imag: r2.imag + t2.imag };
      }, subtract: function(r2, t2) {
        return { real: r2.real - t2.real, imag: r2.imag - t2.imag };
      }, euler: function(r2, t2) {
        var e2 = -2 * Math.PI * r2 / t2;
        return { real: Math.cos(e2), imag: Math.sin(e2) };
      }, conj: function(r2) {
        return r2.imag *= -1, r2;
      }, constructComplexArray: function(r2) {
        var t2 = {};
        t2.real = void 0 === r2.real ? r2.slice() : r2.real.slice();
        var e2 = t2.real.length;
        return void 0 === S[e2] && (S[e2] = Array.apply(null, Array(e2)).map(Number.prototype.valueOf, 0)), t2.imag = S[e2].slice(), t2;
      } }, b = function(r2) {
        var t2 = {};
        void 0 === r2.real || void 0 === r2.imag ? t2 = _.constructComplexArray(r2) : (t2.real = r2.real.slice(), t2.imag = r2.imag.slice());
        var e2 = t2.real.length, a2 = Math.log2(e2);
        if (Math.round(a2) != a2) throw new Error("Input size must be a power of 2.");
        if (t2.real.length != t2.imag.length) throw new Error("Real and imaginary components must have the same length.");
        for (var n2 = _.bitReverseArray(e2), o2 = { real: [], imag: [] }, i2 = 0; i2 < e2; i2++) o2.real[n2[i2]] = t2.real[i2], o2.imag[n2[i2]] = t2.imag[i2];
        for (var u2 = 0; u2 < e2; u2++) t2.real[u2] = o2.real[u2], t2.imag[u2] = o2.imag[u2];
        for (var f2 = 1; f2 <= a2; f2++) for (var c2 = Math.pow(2, f2), l2 = 0; l2 < c2 / 2; l2++) for (var s2 = _.euler(l2, c2), m2 = 0; m2 < e2 / c2; m2++) {
          var p2 = c2 * m2 + l2, h2 = c2 * m2 + l2 + c2 / 2, g2 = { real: t2.real[p2], imag: t2.imag[p2] }, w2 = { real: t2.real[h2], imag: t2.imag[h2] }, v2 = _.multiply(s2, w2), d2 = _.subtract(g2, v2);
          t2.real[h2] = d2.real, t2.imag[h2] = d2.imag;
          var y2 = _.add(v2, g2);
          t2.real[p2] = y2.real, t2.imag[p2] = y2.imag;
        }
        return t2;
      }, M = b, F = (function() {
        function r2(r3, t2) {
          var e2 = this;
          if (this._m = t2, !r3.audioContext) throw this._m.errors.noAC;
          if (r3.bufferSize && !a(r3.bufferSize)) throw this._m._errors.notPow2;
          if (!r3.source) throw this._m._errors.noSource;
          this._m.audioContext = r3.audioContext, this._m.bufferSize = r3.bufferSize || this._m.bufferSize || 256, this._m.hopSize = r3.hopSize || this._m.hopSize || this._m.bufferSize, this._m.sampleRate = r3.sampleRate || this._m.audioContext.sampleRate || 44100, this._m.callback = r3.callback, this._m.windowingFunction = r3.windowingFunction || "hanning", this._m.featureExtractors = v, this._m.EXTRACTION_STARTED = r3.startImmediately || false, this._m.channel = "number" == typeof r3.channel ? r3.channel : 0, this._m.inputs = r3.inputs || 1, this._m.outputs = r3.outputs || 1, this._m.numberOfMFCCCoefficients = r3.numberOfMFCCCoefficients || this._m.numberOfMFCCCoefficients || 13, this._m.numberOfBarkBands = r3.numberOfBarkBands || this._m.numberOfBarkBands || 24, this._m.spn = this._m.audioContext.createScriptProcessor(this._m.bufferSize, this._m.inputs, this._m.outputs), this._m.spn.connect(this._m.audioContext.destination), this._m._featuresToExtract = r3.featureExtractors || [], this._m.barkScale = o(this._m.bufferSize, this._m.sampleRate, this._m.bufferSize), this._m.melFilterBank = f(Math.max(this._m.melBands, this._m.numberOfMFCCCoefficients), this._m.sampleRate, this._m.bufferSize), this._m.inputData = null, this._m.previousInputData = null, this._m.frame = null, this._m.previousFrame = null, this.setSource(r3.source), this._m.spn.onaudioprocess = function(r4) {
            var t3;
            null !== e2._m.inputData && (e2._m.previousInputData = e2._m.inputData), e2._m.inputData = r4.inputBuffer.getChannelData(e2._m.channel), e2._m.previousInputData ? ((t3 = new Float32Array(e2._m.previousInputData.length + e2._m.inputData.length - e2._m.hopSize)).set(e2._m.previousInputData.slice(e2._m.hopSize)), t3.set(e2._m.inputData, e2._m.previousInputData.length - e2._m.hopSize)) : t3 = e2._m.inputData;
            var a2 = (function(r5, t4, e3) {
              if (r5.length < t4) throw new Error("Buffer is too short for frame length");
              if (e3 < 1) throw new Error("Hop length cannot be less that 1");
              if (t4 < 1) throw new Error("Frame length cannot be less that 1");
              var a3 = 1 + Math.floor((r5.length - t4) / e3);
              return new Array(a3).fill(0).map((function(a4, n2) {
                return r5.slice(n2 * e3, n2 * e3 + t4);
              }));
            })(t3, e2._m.bufferSize, e2._m.hopSize);
            a2.forEach((function(r5) {
              e2._m.frame = r5;
              var t4 = e2._m.extract(e2._m._featuresToExtract, e2._m.frame, e2._m.previousFrame);
              "function" == typeof e2._m.callback && e2._m.EXTRACTION_STARTED && e2._m.callback(t4), e2._m.previousFrame = e2._m.frame;
            }));
          };
        }
        return r2.prototype.start = function(r3) {
          this._m._featuresToExtract = r3 || this._m._featuresToExtract, this._m.EXTRACTION_STARTED = true;
        }, r2.prototype.stop = function() {
          this._m.EXTRACTION_STARTED = false;
        }, r2.prototype.setSource = function(r3) {
          this._m.source && this._m.source.disconnect(this._m.spn), this._m.source = r3, this._m.source.connect(this._m.spn);
        }, r2.prototype.setChannel = function(r3) {
          r3 <= this._m.inputs ? this._m.channel = r3 : console.error("Channel ".concat(r3, " does not exist. Make sure you've provided a value for 'inputs' that is greater than ").concat(r3, " when instantiating the MeydaAnalyzer"));
        }, r2.prototype.get = function(r3) {
          return this._m.inputData ? this._m.extract(r3 || this._m._featuresToExtract, this._m.inputData, this._m.previousInputData) : null;
        }, r2;
      })(), A = { audioContext: null, spn: null, bufferSize: 512, sampleRate: 44100, melBands: 26, chromaBands: 12, callback: null, windowingFunction: "hanning", featureExtractors: v, EXTRACTION_STARTED: false, numberOfMFCCCoefficients: 13, numberOfBarkBands: 24, _featuresToExtract: [], windowing: n, _errors: { notPow2: new Error("Meyda: Buffer size must be a power of 2, e.g. 64 or 512"), featureUndef: new Error("Meyda: No features defined."), invalidFeatureFmt: new Error("Meyda: Invalid feature format"), invalidInput: new Error("Meyda: Invalid input."), noAC: new Error("Meyda: No AudioContext specified."), noSource: new Error("Meyda: No source node specified.") }, createMeydaAnalyzer: function(r2) {
        return new F(r2, Object.assign({}, A));
      }, listAvailableFeatureExtractors: function() {
        return Object.keys(this.featureExtractors);
      }, extract: function(r2, t2, e2) {
        var n2 = this;
        if (!t2) throw this._errors.invalidInput;
        if ("object" != typeof t2) throw this._errors.invalidInput;
        if (!r2) throw this._errors.featureUndef;
        if (!a(t2.length)) throw this._errors.notPow2;
        void 0 !== this.barkScale && this.barkScale.length == this.bufferSize || (this.barkScale = o(this.bufferSize, this.sampleRate, this.bufferSize)), void 0 !== this.melFilterBank && this.barkScale.length == this.bufferSize && this.melFilterBank.length == this.melBands || (this.melFilterBank = f(Math.max(this.melBands, this.numberOfMFCCCoefficients), this.sampleRate, this.bufferSize)), void 0 !== this.chromaFilterBank && this.chromaFilterBank.length == this.chromaBands || (this.chromaFilterBank = c(this.chromaBands, this.sampleRate, this.bufferSize)), "buffer" in t2 && void 0 === t2.buffer ? this.signal = i(t2) : this.signal = t2;
        var u2 = E(t2, this.windowingFunction, this.bufferSize);
        if (this.signal = u2.windowedSignal, this.complexSpectrum = u2.complexSpectrum, this.ampSpectrum = u2.ampSpectrum, e2) {
          var l2 = E(e2, this.windowingFunction, this.bufferSize);
          this.previousSignal = l2.windowedSignal, this.previousComplexSpectrum = l2.complexSpectrum, this.previousAmpSpectrum = l2.ampSpectrum;
        }
        var s2 = function(r3) {
          return n2.featureExtractors[r3]({ ampSpectrum: n2.ampSpectrum, chromaFilterBank: n2.chromaFilterBank, complexSpectrum: n2.complexSpectrum, signal: n2.signal, bufferSize: n2.bufferSize, sampleRate: n2.sampleRate, barkScale: n2.barkScale, melFilterBank: n2.melFilterBank, previousSignal: n2.previousSignal, previousAmpSpectrum: n2.previousAmpSpectrum, previousComplexSpectrum: n2.previousComplexSpectrum, numberOfMFCCCoefficients: n2.numberOfMFCCCoefficients, numberOfBarkBands: n2.numberOfBarkBands });
        };
        if ("object" == typeof r2) return r2.reduce((function(r3, t3) {
          var e3;
          return Object.assign({}, r3, ((e3 = {})[t3] = s2(t3), e3));
        }), {});
        if ("string" == typeof r2) return s2(r2);
        throw this._errors.invalidFeatureFmt;
      } }, E = function(r2, t2, e2) {
        var a2 = {};
        void 0 === r2.buffer ? a2.signal = i(r2) : a2.signal = r2, a2.windowedSignal = n(a2.signal, t2), a2.complexSpectrum = M(a2.windowedSignal), a2.ampSpectrum = new Float32Array(e2 / 2);
        for (var o2 = 0; o2 < e2 / 2; o2++) a2.ampSpectrum[o2] = Math.sqrt(Math.pow(a2.complexSpectrum.real[o2], 2) + Math.pow(a2.complexSpectrum.imag[o2], 2));
        return a2;
      };
      return "undefined" != typeof window && (window.Meyda = A), A;
    }));
  }
});
export default require_meyda_min();
//# sourceMappingURL=meyda.js.map
